diff --git a/node_modules/super-three/build/three.js b/node_modules/super-three/build/three.js
index ab70ba3..9541127 100644
--- a/node_modules/super-three/build/three.js
+++ b/node_modules/super-three/build/three.js
@@ -16893,6 +16893,31 @@
 
 	Object.assign(WebVRManager.prototype, EventDispatcher.prototype);
 
+	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
+		var it;
+
+		if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
+			if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
+				if (it) o = it;
+				var i = 0;
+				return function () {
+					if (i >= o.length) return {
+						done: true
+					};
+					return {
+						done: false,
+						value: o[i++]
+					};
+				};
+			}
+
+			throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
+		}
+
+		it = o[Symbol.iterator]();
+		return it.next.bind(it);
+	}
+
 	function WebXRController() {
 		this._targetRay = null;
 		this._grip = null;
@@ -16906,24 +16931,10 @@
 				this._hand = new Group();
 				this._hand.matrixAutoUpdate = false;
 				this._hand.visible = false;
-				this._hand.joints = [];
+				this._hand.joints = {};
 				this._hand.inputState = {
 					pinching: false
 				};
-
-				if (window.XRHand) {
-					for (var i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++) {
-						// The transform of this joint will be updated with the joint pose on each frame
-						var joint = new Group();
-						joint.matrixAutoUpdate = false;
-						joint.visible = false;
-
-						this._hand.joints.push(joint); // ??
-
-
-						this._hand.add(joint);
-					}
-				}
 			}
 
 			return this._hand;
@@ -16993,43 +17004,55 @@
 				if (hand && inputSource.hand) {
 					handPose = true;
 
-					for (var i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++) {
-						if (inputSource.hand[i]) {
-							// Update the joints groups with the XRJoint poses
-							var jointPose = frame.getJointPose(inputSource.hand[i], referenceSpace);
-							var joint = hand.joints[i];
+					for (var _iterator = _createForOfIteratorHelperLoose(inputSource.hand.values()), _step; !(_step = _iterator()).done;) {
+						var inputjoint = _step.value;
+						// Update the joints groups with the XRJoint poses
+						var jointPose = frame.getJointPose(inputjoint, referenceSpace);
 
-							if (jointPose !== null) {
-								joint.matrix.fromArray(jointPose.transform.matrix);
-								joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
-								joint.jointRadius = jointPose.radius;
-							}
+						if (hand.joints[inputjoint.jointName] === undefined) {
+							// The transform of this joint will be updated with the joint pose on each frame
+							var _joint = new Group();
 
-							joint.visible = jointPose !== null; // Custom events
-							// Check pinch
-
-							var indexTip = hand.joints[window.XRHand.INDEX_PHALANX_TIP];
-							var thumbTip = hand.joints[window.XRHand.THUMB_PHALANX_TIP];
-							var distance = indexTip.position.distanceTo(thumbTip.position);
-							var distanceToPinch = 0.02;
-							var threshold = 0.005;
-
-							if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
-								hand.inputState.pinching = false;
-								this.dispatchEvent({
-									type: "pinchend",
-									handedness: inputSource.handedness,
-									target: this
-								});
-							} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
-								hand.inputState.pinching = true;
-								this.dispatchEvent({
-									type: "pinchstart",
-									handedness: inputSource.handedness,
-									target: this
-								});
-							}
+							_joint.matrixAutoUpdate = false;
+							_joint.visible = false;
+							hand.joints[inputjoint.jointName] = _joint; // ??
+
+							hand.add(_joint);
 						}
+
+						var joint = hand.joints[inputjoint.jointName];
+
+						if (jointPose !== null) {
+							joint.matrix.fromArray(jointPose.transform.matrix);
+							joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
+							joint.jointRadius = jointPose.radius;
+						}
+
+						joint.visible = jointPose !== null;
+					} // Custom events
+					// Check pinchz
+
+
+					var indexTip = hand.joints['index-finger-tip'];
+					var thumbTip = hand.joints['thumb-tip'];
+					var distance = indexTip.position.distanceTo(thumbTip.position);
+					var distanceToPinch = 0.02;
+					var threshold = 0.005;
+
+					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
+						hand.inputState.pinching = false;
+						this.dispatchEvent({
+							type: 'pinchend',
+							handedness: inputSource.handedness,
+							target: this
+						});
+					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
+						hand.inputState.pinching = true;
+						this.dispatchEvent({
+							type: 'pinchstart',
+							handedness: inputSource.handedness,
+							target: this
+						});
 					}
 				} else {
 					if (targetRay !== null) {
@@ -17102,7 +17125,7 @@
 			return pose;
 		};
 
-		this.getController = function (id) {
+		this.getController = function (index) {
 			var controller = controllers[index];
 
 			if (controller === undefined) {
@@ -17219,6 +17242,7 @@
 			});
 		};
 
+
 		this.setSession = function (value) {
 			session = value;
 
@@ -17230,37 +17254,45 @@
 				session.addEventListener('squeezestart', onSessionEvent);
 				session.addEventListener('squeezeend', onSessionEvent);
 				session.addEventListener('end', onSessionEnd);
+				session.addEventListener('inputsourceschange', onInputSourceChange);
 				var attributes = gl.getContextAttributes();
 
-				if (attributes.xrCompatible !== true) {
-					gl.makeXRCompatible();
-				}
+				var that = this
+				var onXRCompatible = function () {
+					var layerInit = {
+						antialias: attributes.antialias,
+						alpha: attributes.alpha,
+						depth: attributes.depth,
+						stencil: attributes.stencil,
+						framebufferScaleFactor: framebufferScaleFactor
+					}; // eslint-disable-next-line no-undef
+
+					baseLayer = new XRWebGLLayer(session, gl, layerInit);
+
+					if (window.XRWebGLBinding && that.layersEnabled) {
+						that.addLayer(baseLayer);
+					} else {
+						session.updateRenderState({
+							baseLayer: baseLayer
+						});
+					}
 
-				var layerInit = {
-					antialias: attributes.antialias,
-					alpha: attributes.alpha,
-					depth: attributes.depth,
-					stencil: attributes.stencil,
-					framebufferScaleFactor: framebufferScaleFactor
-				}; // eslint-disable-next-line no-undef
+					session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace); //
 
-				baseLayer = new XRWebGLLayer(session, gl, layerInit);
+				}
 
-				if (window.XRWebGLBinding && this.layersEnabled) {
-					this.addLayer(baseLayer);
+				var xrCompatible = attributes.xrCompatible
+				if (xrCompatible !== true) {
+					return gl.makeXRCompatible().then(onXRCompatible);
 				} else {
-					session.updateRenderState({
-						baseLayer: baseLayer
-					});
+					onXRCompatible()
+					return Promise.resolve()
 				}
 
-				session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace); //
-
-				session.addEventListener('inputsourceschange', updateInputSources);
 			}
 		};
 
-		function updateInputSources(event) {
+		function onInputSourceChange(event) {
 			var inputSources = session.inputSources; // Assign inputSources to available controllers
 
 			for (var i = 0; i < controllers.length; i++) {
@@ -18152,6 +18184,8 @@
 			_this.capabilities = capabilities;
 			_this.extensions = extensions;
 			_this.properties = properties;
+			_this.attributes = attributes;
+			_this.geometries = geometries;
 			_this.renderLists = renderLists;
 			_this.state = state;
 			_this.info = info;
